/**
 * 有符号整型
 *
 * c++只能保证 short int、int、long、long long五种基本整型的最小范围，不能保证在不同系统占用的字节数相同。
 * - short: 至少2字节（16bit）
 * - int: 至少2字节（16bit），在32位和64位系统上通常是4字节（32bit）
 * - long: 至少4字节（32bit），在64位系统上通常是8字节（64bit）
 * - long long: 至少8字节（64bit）
 *
 * 取之范围公式：[-2^(b-1) , 2^(b-1)-1]
 * - b是位数，转成字节表达的公式是 2^(8*byte)
 *
 * 有符号的二进制最高位表示符号位，其余位表示数值部分。
 * 正是因为最高位代表符号，所以有符号会比无符号的正数部分范围小一半。
 *
 * 负数二进制的表示：原码 -> 反码(按位取反) -> 补码加一
 * 例如 -1 的二进制：
 *  - 原码：0000 0001
 *  - 反码：1111 1110
 *  - 补码：1111 1111  ⬅️ 这就是 -1 的二进制码
 *
 * 这种机制是为了计算机做加减运算的时候都只需要使用加法电路：
 *   0000 0001   +1
 * + 1111 1111   -1
 * -----------
 *   0000 0000    0
 *
 * 溢出：
 * C++20 标准做出了如下笼统的声明：“如果在表达式的计算过程中，
 * 结果在数学上未定义或不在其类型的可表示值的范围内，则该行为是未定义的”。通俗地说，这被称为溢出。
 * 编译器可能“回绕”（wrap-around），也可能触发优化假设，甚至崩溃。
 *
 * 向上溢出的二进制计算如下（127 + 1 → 溢出回绕到 -128）：
 *   0 111 1111  (+127)
 * + 0 000 0001  (+1)
 * -----------
 *   1 000 0000  (-128) （最高位是符号，加法运算把符号改变了）
 *
 * 这个计算解释了为什么会发生回绕现象
 *
 * 向下溢出的二进制计算如下（-128 - 1 → 溢出回绕到 +127）：
 *   1 000 0000   (-128)
 * + 1 111 1111   (-1)
 * ------------
 * 1 0 111 1111   (+127) （得到了9位结果，但是只会保留后8位）
 *
 * 编译器默认不会发出溢出警告，因为溢出是未定以行为（Undefined Behavior，UB），
 * 某些情况下也是可以利用这种溢出的。
 *
 * 如果要编译器报错，可以添加参数（clang++）：
 * - 运行时检测：-fsanitize=undefined
 * - 常量表达式编译时检测（静态检测）： -Woverflow
 *
 *
 */

#include <iostream>

int main() {

  // 可以使用 signed 来表名是一个有符号的变量，但是不推荐，一般默认就是 signed
  signed int i { 0 };

  // 4个字节最大值
  int x { 2'147'483'647 };
  std::cout << x << '\n';

  x = x + 1; // 溢出，将导致未定义行为
  std::cout << x << '\n'; // -2147483648

  // 4个字节最小值
  int y { -2'147'483'648 };
  std::cout << y << '\n'; // -2147483648

  y = y - 1; // 溢出
  std::cout << y << '\n'; // 2147483647

  std::cout << 20 / 4 << '\n'; // 5
  std::cout << 8 / 5 << '\n'; // 1  两个整数做除法运算，结果不会隐式转换为浮点数，会抛弃小数部分
  std::cout << 8 / 5.0 << '\n'; // 1.6  其中一个是浮点数，结果会隐式转换为浮点数

  return 0;
}
