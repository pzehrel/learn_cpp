/**
 * 无符号整型
 *
 * C++ 标准明确指出“涉及无符号操作数的计算永远不会溢出”。
 * 如果一个无符号值超出范围，它会被除以该类型最大数值加一的值，并且只保留余数。
 *
 * 数字 280 太大，无法容纳在 0 到 255 的 1 字节范围内。比该类型最大数值大 1 的数是 256。
 * 因此，我们将 280 除以 256，得到 1 余 24。余数 24 就是存储的值。
 *
 * 如果是负数，会变成"回绕"（wrap around）。例如，-1 会变成 255，-2 会变成 254，依此类推：
 *   0000 0000   (0)
 * + 1111 1111   (-1 的补码)
 * ------------
 *   1111 1111    (255)
 *
 * 许多电子游戏史上著名的漏洞都是由于无符号整数的回绕行为造成的。在街机游戏《大金刚》中，
 * 由于溢出漏洞导致用户没有足够的奖励时间来完成关卡，因此无法通过第 22 关。
 *
 * 有符号和无符号整数之间做运算时，通常会将有符号整数转换为无符号整数，这也会导致溢出。
 *
 * 许多开发者（以及一些大型开发公司，如谷歌）认为开发者通常应该避免使用无符号整数。
 * 因为无符号溢出比有符号更容易溢出（只需要小于0）
 *
 * 因此，除非你有充分的理由，否则最好避免使用无符号整数。
 * - 处理器/内存受限的环境
 */

#include <iostream>

int main() {
  // 2个字节的无符号整型（0 ～ 65535）
  unsigned short x { 65535 };

  std::cout << "x sizeof is " << sizeof(x) << " bytes\n";

  std::cout << "x is now: " << x << '\n'; // 65535

  x = 65536;
  std::cout << "x is now: " << x << '\n'; // 65536 % 2^(8*2) = 0 余数为0，所以得到的结果是0

  x = 65537;
  std::cout << "x is now: " << x << '\n'; // 65537 % 2^(8*2) = 1 余数为1，所以得到的结果是1

  x = -1;
  std::cout << "x is now: " << x << '\n'; // -1 % 2^(8*2) = 65535 余数为65535，所以得到的结果是65535

  x = -2;
  std::cout << "x is now: " << x << '\n'; // -2 % 2^(8*2) = 65534 余数为65534，所以得到的结果是65534

  return 0;
}
